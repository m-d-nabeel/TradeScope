// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: assets_queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAsset = `-- name: CreateAsset :exec
INSERT INTO assets (id, class, exchange, symbol, name, status, tradable, marginable, shortable, easy_to_borrow, fractionable, margin_requirement_long, margin_requirement_short, attributes)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
ON CONFLICT (exchange, symbol) DO NOTHING
`

type CreateAssetParams struct {
	ID                     pgtype.UUID
	Class                  AssetClassEnum
	Exchange               ExchangeEnum
	Symbol                 string
	Name                   string
	Status                 AssetStatusEnum
	Tradable               bool
	Marginable             bool
	Shortable              bool
	EasyToBorrow           bool
	Fractionable           bool
	MarginRequirementLong  pgtype.Text
	MarginRequirementShort pgtype.Text
	Attributes             []AttributesEnum
}

// Insert a new asset
func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) error {
	_, err := q.db.Exec(ctx, createAsset,
		arg.ID,
		arg.Class,
		arg.Exchange,
		arg.Symbol,
		arg.Name,
		arg.Status,
		arg.Tradable,
		arg.Marginable,
		arg.Shortable,
		arg.EasyToBorrow,
		arg.Fractionable,
		arg.MarginRequirementLong,
		arg.MarginRequirementShort,
		arg.Attributes,
	)
	return err
}

const deleteAsset = `-- name: DeleteAsset :exec
DELETE FROM assets
WHERE id = $1
`

// Delete an asset
func (q *Queries) DeleteAsset(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAsset, id)
	return err
}

const getAssetByID = `-- name: GetAssetByID :one
SELECT id, class, exchange, symbol, name, status, tradable, marginable, shortable, easy_to_borrow, fractionable, margin_requirement_long, margin_requirement_short, attributes
FROM assets
WHERE id = $1
`

// Get a single asset by ID
func (q *Queries) GetAssetByID(ctx context.Context, id pgtype.UUID) (Asset, error) {
	row := q.db.QueryRow(ctx, getAssetByID, id)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Class,
		&i.Exchange,
		&i.Symbol,
		&i.Name,
		&i.Status,
		&i.Tradable,
		&i.Marginable,
		&i.Shortable,
		&i.EasyToBorrow,
		&i.Fractionable,
		&i.MarginRequirementLong,
		&i.MarginRequirementShort,
		&i.Attributes,
	)
	return i, err
}

const listAssets = `-- name: ListAssets :many
SELECT id, class, exchange, symbol, name, status, tradable, marginable, shortable, easy_to_borrow, fractionable, margin_requirement_long, margin_requirement_short, attributes
FROM assets
`

// Get all assets
func (q *Queries) ListAssets(ctx context.Context) ([]Asset, error) {
	rows, err := q.db.Query(ctx, listAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.Class,
			&i.Exchange,
			&i.Symbol,
			&i.Name,
			&i.Status,
			&i.Tradable,
			&i.Marginable,
			&i.Shortable,
			&i.EasyToBorrow,
			&i.Fractionable,
			&i.MarginRequirementLong,
			&i.MarginRequirementShort,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAsset = `-- name: UpdateAsset :exec
UPDATE assets
SET class = $2, exchange = $3, symbol = $4, name = $5, status = $6, tradable = $7, marginable = $8, shortable = $9, easy_to_borrow = $10, fractionable = $11, margin_requirement_long = $12, margin_requirement_short = $13, attributes = $14
WHERE id = $1
`

type UpdateAssetParams struct {
	ID                     pgtype.UUID
	Class                  AssetClassEnum
	Exchange               ExchangeEnum
	Symbol                 string
	Name                   string
	Status                 AssetStatusEnum
	Tradable               bool
	Marginable             bool
	Shortable              bool
	EasyToBorrow           bool
	Fractionable           bool
	MarginRequirementLong  pgtype.Text
	MarginRequirementShort pgtype.Text
	Attributes             []AttributesEnum
}

// Update an existing asset
func (q *Queries) UpdateAsset(ctx context.Context, arg UpdateAssetParams) error {
	_, err := q.db.Exec(ctx, updateAsset,
		arg.ID,
		arg.Class,
		arg.Exchange,
		arg.Symbol,
		arg.Name,
		arg.Status,
		arg.Tradable,
		arg.Marginable,
		arg.Shortable,
		arg.EasyToBorrow,
		arg.Fractionable,
		arg.MarginRequirementLong,
		arg.MarginRequirementShort,
		arg.Attributes,
	)
	return err
}
