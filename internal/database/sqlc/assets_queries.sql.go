// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: assets_queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAsset = `-- name: CreateAsset :exec
INSERT INTO assets (
    id, seq_id, class, exchange, symbol, name, status, 
    tradable, marginable, shortable, easy_to_borrow, fractionable, 
    maintenance_margin_requirement, margin_requirement_long, margin_requirement_short, attributes
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
)
`

type CreateAssetParams struct {
	ID                           pgtype.UUID
	SeqID                        int32
	Class                        string
	Exchange                     string
	Symbol                       string
	Name                         string
	Status                       string
	Tradable                     bool
	Marginable                   bool
	Shortable                    bool
	EasyToBorrow                 bool
	Fractionable                 bool
	MaintenanceMarginRequirement pgtype.Int4
	MarginRequirementLong        pgtype.Text
	MarginRequirementShort       pgtype.Text
	Attributes                   []string
}

// Insert a new asset
func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) error {
	_, err := q.db.Exec(ctx, createAsset,
		arg.ID,
		arg.SeqID,
		arg.Class,
		arg.Exchange,
		arg.Symbol,
		arg.Name,
		arg.Status,
		arg.Tradable,
		arg.Marginable,
		arg.Shortable,
		arg.EasyToBorrow,
		arg.Fractionable,
		arg.MaintenanceMarginRequirement,
		arg.MarginRequirementLong,
		arg.MarginRequirementShort,
		arg.Attributes,
	)
	return err
}

type CreateAssetsBatchParams struct {
	ID                           pgtype.UUID
	SeqID                        int32
	Class                        string
	Exchange                     string
	Symbol                       string
	Name                         string
	Tradable                     bool
	Marginable                   bool
	Shortable                    bool
	EasyToBorrow                 bool
	Fractionable                 bool
	Status                       string
	MaintenanceMarginRequirement pgtype.Int4
	Attributes                   []string
}

const getAssetByID = `-- name: GetAssetByID :one
SELECT id, seq_id, class, exchange, symbol, name, status, tradable, marginable, shortable, easy_to_borrow, fractionable, maintenance_margin_requirement, margin_requirement_long, margin_requirement_short, attributes FROM assets
WHERE id = $1
`

// Get a single asset by ID
func (q *Queries) GetAssetByID(ctx context.Context, id pgtype.UUID) (Asset, error) {
	row := q.db.QueryRow(ctx, getAssetByID, id)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.Class,
		&i.Exchange,
		&i.Symbol,
		&i.Name,
		&i.Status,
		&i.Tradable,
		&i.Marginable,
		&i.Shortable,
		&i.EasyToBorrow,
		&i.Fractionable,
		&i.MaintenanceMarginRequirement,
		&i.MarginRequirementLong,
		&i.MarginRequirementShort,
		&i.Attributes,
	)
	return i, err
}

const getAssetsByStatusAndTradability = `-- name: GetAssetsByStatusAndTradability :many
SELECT id, seq_id, class, exchange, symbol, name, status, tradable, marginable, shortable, easy_to_borrow, fractionable, maintenance_margin_requirement, margin_requirement_long, margin_requirement_short, attributes FROM assets
WHERE status = $1 AND tradable = $2
ORDER BY symbol
`

type GetAssetsByStatusAndTradabilityParams struct {
	Status   string
	Tradable bool
}

// Get assets by status and tradability
func (q *Queries) GetAssetsByStatusAndTradability(ctx context.Context, arg GetAssetsByStatusAndTradabilityParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByStatusAndTradability, arg.Status, arg.Tradable)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.Class,
			&i.Exchange,
			&i.Symbol,
			&i.Name,
			&i.Status,
			&i.Tradable,
			&i.Marginable,
			&i.Shortable,
			&i.EasyToBorrow,
			&i.Fractionable,
			&i.MaintenanceMarginRequirement,
			&i.MarginRequirementLong,
			&i.MarginRequirementShort,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsBySymbol = `-- name: GetAssetsBySymbol :many
SELECT id, seq_id, class, exchange, symbol, name, status, tradable, marginable, shortable, easy_to_borrow, fractionable, maintenance_margin_requirement, margin_requirement_long, margin_requirement_short, attributes FROM assets
WHERE LOWER(symbol) = LOWER($1)
ORDER BY exchange
`

// Get assets by symbol (case-insensitive)
func (q *Queries) GetAssetsBySymbol(ctx context.Context, lower string) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsBySymbol, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.Class,
			&i.Exchange,
			&i.Symbol,
			&i.Name,
			&i.Status,
			&i.Tradable,
			&i.Marginable,
			&i.Shortable,
			&i.EasyToBorrow,
			&i.Fractionable,
			&i.MaintenanceMarginRequirement,
			&i.MarginRequirementLong,
			&i.MarginRequirementShort,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsWithKeysetPagination = `-- name: GetAssetsWithKeysetPagination :many
SELECT id, seq_id, class, exchange, symbol, name, status, tradable, marginable, shortable, easy_to_borrow, fractionable, maintenance_margin_requirement, margin_requirement_long, margin_requirement_short, attributes FROM assets
WHERE seq_id > $1
ORDER BY seq_id ASC
LIMIT $2
`

type GetAssetsWithKeysetPaginationParams struct {
	SeqID int32
	Limit int32
}

// Get assets with keyset pagination
func (q *Queries) GetAssetsWithKeysetPagination(ctx context.Context, arg GetAssetsWithKeysetPaginationParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsWithKeysetPagination, arg.SeqID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.Class,
			&i.Exchange,
			&i.Symbol,
			&i.Name,
			&i.Status,
			&i.Tradable,
			&i.Marginable,
			&i.Shortable,
			&i.EasyToBorrow,
			&i.Fractionable,
			&i.MaintenanceMarginRequirement,
			&i.MarginRequirementLong,
			&i.MarginRequirementShort,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssets = `-- name: ListAssets :many
SELECT id, seq_id, class, exchange, symbol, name, status, tradable, marginable, shortable, easy_to_borrow, fractionable, maintenance_margin_requirement, margin_requirement_long, margin_requirement_short, attributes FROM assets
ORDER BY symbol
`

// Get all assets
func (q *Queries) ListAssets(ctx context.Context) ([]Asset, error) {
	rows, err := q.db.Query(ctx, listAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.Class,
			&i.Exchange,
			&i.Symbol,
			&i.Name,
			&i.Status,
			&i.Tradable,
			&i.Marginable,
			&i.Shortable,
			&i.EasyToBorrow,
			&i.Fractionable,
			&i.MaintenanceMarginRequirement,
			&i.MarginRequirementLong,
			&i.MarginRequirementShort,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const swapAssets = `-- name: SwapAssets :exec
TRUNCATE TABLE assets
`

func (q *Queries) SwapAssets(ctx context.Context) error {
	_, err := q.db.Exec(ctx, swapAssets)
	return err
}

const truncateAssets = `-- name: TruncateAssets :exec
TRUNCATE TABLE assets
`

// Truncate the assets table
func (q *Queries) TruncateAssets(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateAssets)
	return err
}

const truncateAssetsStaging = `-- name: TruncateAssetsStaging :exec
TRUNCATE TABLE assets
`

func (q *Queries) TruncateAssetsStaging(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateAssetsStaging)
	return err
}
